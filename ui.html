<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dir-mimic</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 20px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #333;
}

h1 {
  font-size: 1.5rem;
  font-weight: 500;
  color: #fff;
}

.btn {
  background: #4a9eff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.2s;
}

.btn:hover {
  background: #3a8eef;
}

.btn:disabled {
  background: #555;
  cursor: not-allowed;
}

.dropzone {
  border: 2px dashed #444;
  border-radius: 12px;
  padding: 60px 20px;
  text-align: center;
  transition: all 0.2s;
  margin-bottom: 20px;
  cursor: pointer;
}

.dropzone:hover, .dropzone.dragover {
  border-color: #4a9eff;
  background: rgba(74, 158, 255, 0.1);
}

.dropzone-text {
  color: #888;
  font-size: 1rem;
}

.dropzone-text strong {
  color: #ccc;
}

.scanning {
  color: #4a9eff;
}

.tree {
  background: #252540;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 15px;
  max-height: 500px;
  overflow-y: auto;
}

.tree-node {
  margin: 2px 0;
}

.tree-folder {
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tree-folder:hover {
  background: rgba(255, 255, 255, 0.05);
}

.tree-folder-icon {
  transition: transform 0.2s;
}

.tree-folder.collapsed .tree-folder-icon {
  transform: rotate(-90deg);
}

.tree-children {
  margin-left: 20px;
  border-left: 1px solid #333;
  padding-left: 10px;
}

.tree-children.hidden {
  display: none;
}

.tree-file {
  padding: 3px 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
}

.op-mv { color: #6eb5ff; }
.op-mv::before { content: "‚ÜîÔ∏è "; }
.op-cp { color: #6eff9e; }
.op-cp::before { content: "üìã "; }
.op-rm { color: #ff6e6e; }
.op-rm::before { content: "üóëÔ∏è "; }
.op-missing { color: #888; }
.op-missing::before { content: "‚ûï "; }

.folder-stats {
  font-size: 0.8rem;
  color: #666;
  margin-left: auto;
}

.summary {
  background: #252540;
  border-radius: 8px;
  padding: 12px 15px;
  font-size: 0.9rem;
  color: #aaa;
}

.summary span {
  margin-right: 15px;
}

.summary .mv { color: #6eb5ff; }
.summary .cp { color: #6eff9e; }
.summary .rm { color: #ff6e6e; }
.summary .missing { color: #888; }

.status {
  padding: 15px;
  border-radius: 8px;
  margin: 15px 0;
  text-align: center;
}

.status.success {
  background: rgba(110, 255, 158, 0.1);
  color: #6eff9e;
}

.status.error {
  background: rgba(255, 110, 110, 0.1);
  color: #ff6e6e;
}

.status.pending {
  background: rgba(74, 158, 255, 0.1);
  color: #4a9eff;
}

.empty-state {
  text-align: center;
  padding: 40px;
  color: #666;
}

.checksum {
  font-family: monospace;
  font-size: 0.85rem;
  color: #f0a040;
  margin-top: 8px;
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>dir-mimic</h1>
    <div id="serverConfig" style="display: none;">
      <input type="text" id="serverInput" placeholder="server:port" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #444; background: #252540; color: #eee; font-size: 0.9rem; width: 150px;">
      <button class="btn" id="connectBtn">Connect</button>
      <span id="connectedStatus" style="display: none; color: #6eff9e; font-size: 0.85rem;">‚úì Connected</span>
    </div>
    <button class="btn" id="applyBtn" disabled>Apply Changes</button>
  </header>

  <div id="serverInfo" style="display: none; background: #252540; border-radius: 8px; padding: 12px 15px; font-size: 0.85rem; color: #aaa; margin-bottom: 20px;"></div>

  <div class="dropzone" id="dropzone">
    <div class="dropzone-text" id="dropzoneText">
      <strong>Drag & drop your source folder here</strong><br>
      or click to select
    </div>
  </div>
  <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">

  <div id="content">
    <div class="empty-state">
      Drop a folder above to compare with the server directory
    </div>
  </div>

  <div class="summary" id="summary" style="display: none;">
    <span class="mv">0 moves</span>
    <span class="cp">0 copies</span>
    <span class="rm">0 deletes</span>
    <span class="missing">0 missing files</span>
  </div>
</div>

<script>
// Pure JS SHA-256 implementation (works without crypto.subtle)
const sha256 = (function() {
  const K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ]);

  function rotr(x, n) { return (x >>> n) | (x << (32 - n)); }

  function hash(message) {
    const bytes = new TextEncoder().encode(message);
    const len = bytes.length;
    const bitLen = len * 8;

    // Padding
    const padLen = (len % 64 < 56) ? 56 - len % 64 : 120 - len % 64;
    const padded = new Uint8Array(len + padLen + 8);
    padded.set(bytes);
    padded[len] = 0x80;
    const view = new DataView(padded.buffer);
    view.setUint32(padded.length - 4, bitLen, false);

    // Initial hash values
    let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
    let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;

    const w = new Uint32Array(64);

    for (let i = 0; i < padded.length; i += 64) {
      for (let j = 0; j < 16; j++) {
        w[j] = view.getUint32(i + j * 4, false);
      }
      for (let j = 16; j < 64; j++) {
        const s0 = rotr(w[j-15], 7) ^ rotr(w[j-15], 18) ^ (w[j-15] >>> 3);
        const s1 = rotr(w[j-2], 17) ^ rotr(w[j-2], 19) ^ (w[j-2] >>> 10);
        w[j] = (w[j-16] + s0 + w[j-7] + s1) >>> 0;
      }

      let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;

      for (let j = 0; j < 64; j++) {
        const S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
        const ch = (e & f) ^ (~e & g);
        const t1 = (h + S1 + ch + K[j] + w[j]) >>> 0;
        const S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
        const maj = (a & b) ^ (a & c) ^ (b & c);
        const t2 = (S0 + maj) >>> 0;
        h = g; g = f; f = e; e = (d + t1) >>> 0;
        d = c; c = b; b = a; a = (t1 + t2) >>> 0;
      }

      h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
      h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
    }

    const hex = x => x.toString(16).padStart(8, '0');
    return hex(h0) + hex(h1) + hex(h2) + hex(h3) + hex(h4) + hex(h5) + hex(h6) + hex(h7);
  }

  return hash;
})();

// State
let serverCatalog = [];
let sourceCatalog = [];
let operations = [];
let serverBaseUrl = ''; // Empty for same-origin, or 'http://host:port' for remote
let ignorePatterns = [];

// Glob match against basename: supports * and ? wildcards
function globMatch(pattern, name) {
  // Convert glob pattern to regex
  let re = '^';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern[i];
    if (c === '*') re += '.*';
    else if (c === '?') re += '.';
    else if ('.+^${}()|[]\\'.includes(c)) re += '\\' + c;
    else re += c;
  }
  re += '$';
  return new RegExp(re).test(name);
}

function shouldIgnore(filename) {
  for (const pattern of ignorePatterns) {
    if (globMatch(pattern, filename)) return true;
  }
  return false;
}

// DOM elements
const dropzone = document.getElementById('dropzone');
const dropzoneText = document.getElementById('dropzoneText');
const content = document.getElementById('content');
const summary = document.getElementById('summary');
const applyBtn = document.getElementById('applyBtn');
const serverConfig = document.getElementById('serverConfig');
const serverInput = document.getElementById('serverInput');
const connectBtn = document.getElementById('connectBtn');
const connectedStatus = document.getElementById('connectedStatus');
const serverInfo = document.getElementById('serverInfo');

// Check if running from file:// protocol
const isFileProtocol = window.location.protocol === 'file:';

// Fetch server catalog
async function loadCatalog() {
  try {
    const res = await fetch(serverBaseUrl + '/catalog');
    const data = await res.json();
    serverCatalog = data.files;
    ignorePatterns = data.ignorePatterns || [];
    console.log('Server catalog loaded:', serverCatalog.length, 'files, ignore patterns:', ignorePatterns);

    // Show connected status
    if (isFileProtocol) {
      serverInput.style.display = 'none';
      connectBtn.style.display = 'none';
      connectedStatus.style.display = 'inline';
    }

    // Show server info
    serverInfo.style.display = 'block';
    serverInfo.innerHTML = '<strong style="color: #ccc;">' + data.path + '</strong><br>' +
      data.fileCount + ' files, ' + data.folderCount + ' folders, ' + formatSize(data.totalSize);

    content.innerHTML = '<div class="empty-state">Drop a folder above to compare with the server directory</div>';
  } catch (err) {
    console.error('Failed to load catalog:', err);
    content.innerHTML = '<div class="status error">Failed to load server catalog</div>';
  }
}

// Initialize based on protocol
async function init() {
  if (isFileProtocol) {
    // Show server config UI
    serverConfig.style.display = 'flex';
    serverConfig.style.gap = '10px';
    serverConfig.style.alignItems = 'center';
    content.innerHTML = '<div class="empty-state">Enter server address above to connect</div>';

    // Try to restore from localStorage
    const savedServer = localStorage.getItem('dir-mimic-server');
    if (savedServer) {
      serverInput.value = savedServer;
    }
  } else {
    // Running from server, use same-origin
    await loadCatalog();
  }
}

// Connect button handler
connectBtn.addEventListener('click', async () => {
  const server = serverInput.value.trim();
  if (!server) {
    content.innerHTML = '<div class="status error">Please enter a server address</div>';
    return;
  }

  // Add http:// if no protocol specified
  serverBaseUrl = server.includes('://') ? server : 'http://' + server;

  // Save to localStorage
  localStorage.setItem('dir-mimic-server', server);

  content.innerHTML = '<div class="status pending">Connecting to ' + serverBaseUrl + '...</div>';
  await loadCatalog();
});

// Allow pressing Enter in server input
serverInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    connectBtn.click();
  }
});

init();

// Drag & drop handling
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragleave', () => {
  dropzone.classList.remove('dragover');
});

dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropzone.classList.remove('dragover');

  const items = e.dataTransfer.items;
  if (!items || items.length === 0) return;

  // Try File System Access API first (Chrome)
  if (items[0].getAsFileSystemHandle) {
    try {
      const handle = await items[0].getAsFileSystemHandle();
      if (handle.kind === 'directory') {
        await scanDirectoryHandle(handle);
        return;
      }
    } catch (err) {
      console.log('File System Access API failed, trying fallback');
    }
  }

  // Fallback: webkitGetAsEntry
  const item = items[0];
  if (item.webkitGetAsEntry) {
    const entry = item.webkitGetAsEntry();
    if (entry && entry.isDirectory) {
      await scanWebkitEntry(entry);
      return;
    }
  }

  dropzoneText.innerHTML = '<span style="color: #ff6e6e;">Please drop a folder, not a file</span>';
});

const folderInput = document.getElementById('folderInput');

dropzone.addEventListener('click', async () => {
  // Try File System Access API for directory picker (requires secure context)
  if ('showDirectoryPicker' in window && window.isSecureContext) {
    try {
      const handle = await window.showDirectoryPicker();
      await scanDirectoryHandle(handle);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Directory picker failed:', err);
      }
    }
  } else {
    // Fallback: use hidden file input with webkitdirectory
    folderInput.click();
  }
});

// Handle folder selection via file input (works in non-secure contexts)
folderInput.addEventListener('change', async (e) => {
  const files = e.target.files;
  if (!files || files.length === 0) return;

  dropzoneText.innerHTML = '<span class="scanning">Scanning folder...</span>';
  sourceCatalog = [];

  // Extract folder name from first file's path
  let folderName = '';
  if (files[0].webkitRelativePath) {
    folderName = files[0].webkitRelativePath.split('/')[0];
  }

  for (const file of files) {
    // webkitRelativePath gives us "folder/subfolder/file.txt"
    // We want to strip the root folder name
    let path = file.webkitRelativePath;
    if (path.startsWith(folderName + '/')) {
      path = path.substring(folderName.length + 1);
    }

    // Check if any path component should be ignored
    const parts = path.split('/');
    if (parts.some(p => shouldIgnore(p))) continue;

    sourceCatalog.push({
      path: path,
      size: file.size,
      mtime: file.lastModified
    });
  }

  console.log('Source catalog:', sourceCatalog.length, 'files');
  dropzoneText.innerHTML = '<strong>' + folderName + '</strong><br>' + sourceCatalog.length + ' files scanned';
  computeDiff();

  // Reset input so same folder can be selected again
  folderInput.value = '';
});

// Scan directory using File System Access API
async function scanDirectoryHandle(dirHandle, basePath = '') {
  dropzoneText.innerHTML = '<span class="scanning">Scanning folder...</span>';
  sourceCatalog = [];

  async function walkDir(handle, path) {
    for await (const entry of handle.values()) {
      if (shouldIgnore(entry.name)) continue;
      const entryPath = path ? path + '/' + entry.name : entry.name;
      if (entry.kind === 'directory') {
        await walkDir(entry, entryPath);
      } else {
        try {
          const file = await entry.getFile();
          sourceCatalog.push({
            path: entryPath,
            size: file.size,
            mtime: file.lastModified
          });
        } catch (err) {
          console.warn('Could not read file:', entryPath, err);
        }
      }
    }
  }

  await walkDir(dirHandle, '');
  console.log('Source catalog:', sourceCatalog.length, 'files');
  dropzoneText.innerHTML = '<strong>' + dirHandle.name + '</strong><br>' + sourceCatalog.length + ' files scanned';
  computeDiff();
}

// Scan directory using webkit fallback
async function scanWebkitEntry(entry) {
  dropzoneText.innerHTML = '<span class="scanning">Scanning folder...</span>';
  sourceCatalog = [];

  function readEntries(dirReader) {
    return new Promise((resolve) => {
      dirReader.readEntries(resolve);
    });
  }

  function readFile(fileEntry) {
    return new Promise((resolve, reject) => {
      fileEntry.file(resolve, reject);
    });
  }

  async function walkEntry(entry, path) {
    if (shouldIgnore(entry.name)) return;
    if (entry.isFile) {
      try {
        const file = await readFile(entry);
        sourceCatalog.push({
          path: path,
          size: file.size,
          mtime: file.lastModified
        });
      } catch (err) {
        console.warn('Could not read file:', path, err);
      }
    } else if (entry.isDirectory) {
      const reader = entry.createReader();
      let entries;
      do {
        entries = await readEntries(reader);
        for (const child of entries) {
          const childPath = path ? path + '/' + child.name : child.name;
          await walkEntry(child, childPath);
        }
      } while (entries.length > 0);
    }
  }

  await walkEntry(entry, '');
  console.log('Source catalog:', sourceCatalog.length, 'files');
  dropzoneText.innerHTML = '<strong>' + entry.name + '</strong><br>' + sourceCatalog.length + ' files scanned';
  computeDiff();
}

// Compute diff between source and server catalogs
function computeDiff() {
  operations = [];

  // Build key maps: key = filename + '|' + size
  function makeKey(entry) {
    const filename = entry.path.split('/').pop();
    return filename + '|' + entry.size + (entry.hash ? '|' + entry.hash : '');
  }

  function getFolder(path) {
    const parts = path.split('/');
    parts.pop();
    return parts.join('/');
  }

  // Map: key -> [folders]
  const sourceFolders = new Map();
  const destFolders = new Map();

  for (const entry of sourceCatalog) {
    const key = makeKey(entry);
    if (!sourceFolders.has(key)) sourceFolders.set(key, []);
    sourceFolders.get(key).push({folder: getFolder(entry.path), path: entry.path, size: entry.size});
  }

  for (const entry of serverCatalog) {
    const key = makeKey(entry);
    if (!destFolders.has(key)) destFolders.set(key, []);
    destFolders.get(key).push({folder: getFolder(entry.path), path: entry.path});
  }

  // Get all unique keys
  const allKeys = new Set([...sourceFolders.keys(), ...destFolders.keys()]);

  for (const key of allKeys) {
    const srcFolderList = sourceFolders.get(key) || [];
    const dstFolderList = destFolders.get(key) || [];

    const srcFolderSet = new Set(srcFolderList.map(f => f.folder));
    const dstFolderSet = new Set(dstFolderList.map(f => f.folder));

    if (srcFolderList.length === 0 && dstFolderList.length > 0) {
      // Only in destination - delete
      for (const dst of dstFolderList) {
        operations.push({type: 'rm', from: dst.path});
      }
    } else if (srcFolderList.length > 0 && dstFolderList.length === 0) {
      // Only in source - missing
      for (const src of srcFolderList) {
        operations.push({type: 'missing', from: src.path, size: src.size});
      }
    } else {
      // In both - compare folders
      const onlyInSrc = srcFolderList.filter(s => !dstFolderSet.has(s.folder));
      const onlyInDst = dstFolderList.filter(d => !srcFolderSet.has(d.folder));

      if (onlyInSrc.length === 0 && onlyInDst.length === 0) continue;

      // Move where possible
      const moveCount = Math.min(onlyInSrc.length, onlyInDst.length);
      for (let i = 0; i < moveCount; i++) {
        operations.push({
          type: 'mv',
          from: onlyInDst[i].path,
          to: onlyInSrc[i].path
        });
      }

      // Delete extra files in destination
      for (let i = moveCount; i < onlyInDst.length; i++) {
        operations.push({type: 'rm', from: onlyInDst[i].path});
      }

      // Copy for extra files needed in source locations
      if (onlyInSrc.length > moveCount && dstFolderList.length > 0) {
        for (let i = moveCount; i < onlyInSrc.length; i++) {
          operations.push({
            type: 'cp',
            from: dstFolderList[0].path,
            to: onlyInSrc[i].path
          });
        }
      }
    }
  }

  // Sort operations
  operations.sort((a, b) => a.from.localeCompare(b.from));

  renderTree();
  updateSummary();
}

// Build tree structure from operations
function buildTree(ops) {
  const root = {name: '', children: new Map(), ops: []};

  for (const op of ops) {
    const path = op.from;
    const parts = path.split('/');
    let node = root;

    // Navigate/create path to parent folder
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!node.children.has(part)) {
        node.children.set(part, {name: part, children: new Map(), ops: []});
      }
      node = node.children.get(part);
    }

    node.ops.push({...op, filename: parts[parts.length - 1]});
  }

  return root;
}

// Count operations in a subtree
function countOps(node) {
  const counts = {mv: 0, cp: 0, rm: 0, missing: 0, missingSize: 0};

  for (const op of node.ops) {
    counts[op.type]++;
    if (op.type === 'missing' && op.size) {
      counts.missingSize += op.size;
    }
  }

  for (const child of node.children.values()) {
    const childCounts = countOps(child);
    counts.mv += childCounts.mv;
    counts.cp += childCounts.cp;
    counts.rm += childCounts.rm;
    counts.missing += childCounts.missing;
    counts.missingSize += childCounts.missingSize;
  }

  return counts;
}

// Format file size
function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
}

// Render tree to HTML
function renderTree() {
  const tree = buildTree(operations);

  if (operations.length === 0) {
    content.innerHTML = '<div class="empty-state">No differences found - directories are in sync!</div>';
    applyBtn.disabled = true;
    return;
  }

  function renderNode(node, isRoot = false) {
    let html = '';

    // Sort children by name
    const sortedChildren = [...node.children.entries()].sort((a, b) => a[0].localeCompare(b[0]));

    for (const [name, child] of sortedChildren) {
      const counts = countOps(child);
      const hasOps = counts.mv + counts.cp + counts.rm + counts.missing > 0;
      if (!hasOps) continue;

      const statsArr = [];
      if (counts.mv) statsArr.push(counts.mv + ' move' + (counts.mv > 1 ? 's' : ''));
      if (counts.cp) statsArr.push(counts.cp + ' cop' + (counts.cp > 1 ? 'ies' : 'y'));
      if (counts.rm) statsArr.push(counts.rm + ' delete' + (counts.rm > 1 ? 's' : ''));
      if (counts.missing) statsArr.push('+' + counts.missing + ' file' + (counts.missing > 1 ? 's' : '') +
        (counts.missingSize > 0 ? ' (' + formatSize(counts.missingSize) + ')' : ''));

      const id = 'node-' + Math.random().toString(36).substr(2, 9);

      html += '<div class="tree-node">';
      html += '<div class="tree-folder" onclick="toggleFolder(\'' + id + '\', this)">';
      html += '<span class="tree-folder-icon">&#9660;</span>';
      html += '<span>&#128193; ' + name + '</span>';
      html += '<span class="folder-stats">' + statsArr.join(', ') + '</span>';
      html += '</div>';
      html += '<div class="tree-children" id="' + id + '">';
      html += renderNode(child);
      html += '</div>';
      html += '</div>';
    }

    // Sort and render operations
    const sortedOps = [...node.ops].sort((a, b) => a.filename.localeCompare(b.filename));
    for (const op of sortedOps) {
      html += '<div class="tree-file op-' + op.type + '">';
      if (op.type === 'mv') {
        html += op.filename + ' &#8594; ' + getFolder(op.to) + '/';
      } else if (op.type === 'cp') {
        html += op.filename + ' (copy to ' + getFolder(op.to) + '/)';
      } else if (op.type === 'rm') {
        html += op.filename;
      } else if (op.type === 'missing') {
        html += op.filename + (op.size ? ' (' + formatSize(op.size) + ')' : '');
      }
      html += '</div>';
    }

    return html;
  }

  function getFolder(path) {
    if (!path) return '';
    const parts = path.split('/');
    parts.pop();
    return parts.join('/') || '.';
  }

  content.innerHTML = '<div class="tree">' + renderNode(tree, true) + '</div>';
  applyBtn.disabled = false;
}

// Toggle folder collapse
window.toggleFolder = function(id, elem) {
  const children = document.getElementById(id);
  if (children) {
    children.classList.toggle('hidden');
    elem.classList.toggle('collapsed');
  }
};

// Update summary bar
function updateSummary() {
  const counts = {mv: 0, cp: 0, rm: 0, missing: 0, missingSize: 0};
  for (const op of operations) {
    counts[op.type]++;
    if (op.type === 'missing' && op.size) {
      counts.missingSize += op.size;
    }
  }

  summary.style.display = 'block';
  summary.innerHTML =
    '<span class="mv">' + counts.mv + ' move' + (counts.mv !== 1 ? 's' : '') + '</span>' +
    '<span class="cp">' + counts.cp + ' cop' + (counts.cp !== 1 ? 'ies' : 'y') + '</span>' +
    '<span class="rm">' + counts.rm + ' delete' + (counts.rm !== 1 ? 's' : '') + '</span>' +
    '<span class="missing">' + counts.missing + ' missing' +
      (counts.missingSize > 0 ? ' (' + formatSize(counts.missingSize) + ')' : '') + '</span>';
}

// Apply changes
applyBtn.addEventListener('click', async () => {
  // Filter out missing operations (nothing to do on server for those)
  const executableOps = operations.filter(op => op.type !== 'missing');

  if (executableOps.length === 0) {
    alert('No executable operations. Missing files need to be copied from source using rsync or similar.');
    return;
  }

  // Build payload and compute checksum of exact bytes to be sent
  const payload = JSON.stringify({operations: executableOps});
  const checksum = sha256(payload);

  // Show checksum in UI before sending
  content.innerHTML = '<div class="status pending">Sending plan to server. Verify checksum matches terminal:<div class="checksum">' + checksum + '</div></div>';

  applyBtn.disabled = true;
  applyBtn.textContent = 'Waiting for confirmation...';

  try {
    const res = await fetch(serverBaseUrl + '/apply', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: payload
    });

    const result = await res.json();

    if (result.status === 'completed') {
      if (result.errors && result.errors.length > 0) {
        content.innerHTML = '<div class="status error">Completed with ' + result.errors.length + ' error(s)</div>';
      } else {
        content.innerHTML = '<div class="status success">All operations completed successfully!</div>';
      }
      // Reload catalog
      const catalogRes = await fetch(serverBaseUrl + '/catalog');
      const catalogData = await catalogRes.json();
      serverCatalog = catalogData.files;
      ignorePatterns = catalogData.ignorePatterns || [];
      // Update server info
      serverInfo.innerHTML = '<strong style="color: #ccc;">' + catalogData.path + '</strong><br>' +
        catalogData.fileCount + ' files, ' + catalogData.folderCount + ' folders, ' + formatSize(catalogData.totalSize);
      operations = [];
      summary.style.display = 'none';
    } else {
      content.innerHTML = '<div class="status error">Plan was aborted in the terminal.</div>';
    }
  } catch (err) {
    content.innerHTML = '<div class="status error">Error: ' + err.message + '</div>';
  }

  applyBtn.textContent = 'Apply Changes';
  applyBtn.disabled = true;
});
</script>
</body>
</html>
